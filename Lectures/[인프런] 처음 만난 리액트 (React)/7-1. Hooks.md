### 강의 내용

- HOOK
  - 리액터 버전 16.8에서 새로 나온 개념.
  - 클래서 컴포넌트에서는,
    - 생성자에서 state를 정의
    - setState() 함수를 통해 state 업데이트
    - Lifecycle methods 제공
  - 하지만 함수 컴포넌트에서는,
    - state 사용 불가
    - Lifecycle에 따른 기능 구현 불가
    - 그래서 함수 컴포넌트에서 이를 보완하기 위해 나온 것이 훅임.
    - 훅을 사용하면 함수 컴포넌트도 클래스 컴포넌트의 모든 기능을 동일하게 구현할 수 있음.
  - 훅은 갈고리 라는 의미인데, 원하는 시점에 갈고리를 걸어 정해진 함수를 실행되도록 만든 것임.
  - 모든 훅은 use로 시작함.
  - 개발자가 커스텀 훅을 만들 수도 있는데, 훅이라는 것을 나타내기 위해 use를 붙여줘야 함.
- useState
  - state를 사용하기 위한 훅.
  - const [변수명, set함수명] = useState(초기값)
- useEffect
  - side effect를 수행하기 위한 훅
    - 원래 side effect는 부작용. 개발자가 의도하지 않은 버그가 발행하는 경우를 말함.
    - 하지만 리액트에서는 부정적인 의미는 아니고, 효과 혹은 영향을 말함. 서버에서 데이터를 받아오거나 DOM을 변경하는 작업을 말함.
    - 이 작업들을 effect라고 부르는 이유는, 이 작업들이 다른 컴포넌트에 영향을 미칠 수 있으며 렌더링 중에는 작업이 완료될 수 없기 때문임. 렌더링이 끝난 이후에 실행되어야 하는 작업들임.
    - 이 작업들이 side로 실행된다고 해서 side effect라고 불리며, useEffect를 통해 이 side effect를 실행할 수 있음.
  - 생명주기 함수와 동일한 기능을 하나로 통합해서 제공함.
  - useEffect(이펙트 함수, 의존성 배열);
    - 이펙트가 의존하고 있는 배열인데, 배열 중 하나라도 값이 변경되면 이펙트 함수가 실행됨.
  - useEffect(이펙트 함수,[])
    - props나 state 어떤 값에도 의존하지 않는 것이므로 여러 번 실행되지 않고 mount, unmount 시에 한 번씩만 실행됨.
  - 의존성 배열을 생략하면
    - 컴포넌트가 업데이트 될 때마다 이펙트 함수가 실행됨.
    - 리액트는 돔이 변경된 이후에 해당 이펙트 함수를 실행하라고 이해함.
    - 그래서 처음 렌더링을 포함하여 매번 렌더링 될 때마다 실행됨
  - componentWillUnmount와 동일한 기능
    - useEffect에서의 return 함수의 역할이 동일한 역할을 함.
  - 하나의 컴포넌트에서 여러 개의 훅을 사용할 수 있음.
- useMemo
  - memoized value를 return 하는 훅.
  - memoization
    - 비용이 높은, 연산량이 높은 함수 호출 결과를 저장해뒀다가, 같은 입력값으로 함수를 호출하면 새로 함수를 호출하지 않고 이전에 저장해뒀던 호출 결과를 바로 반환하는 것.
    - 함수 호출 결과를 받기까지 시간 빨라지고, 불필요한 중복 연산 하지 않아서 컴퓨터 자원을 덜 씀.
  - 파라미터로 함수와 의존성 배열 있음. 의존성 배열에 들어있는 변수가 변했을 경우에만 새로 결과값 반환함.
  - 컴포넌트가 렌더링 될 때마다 복잡한 연산 반복하는 것을 방지할 수 있음.
  - 결과적으로는 렌더링 속도 빨라짐.
  - useMemo로 전달된 함수는 렌더링이 일어나는 동안 실행됨. -> 렌더링이 일어나는 동안 실행되면 안되는 작업을 useMemo로 전달하면 안됨.
    - 예를 들어, 서버에서 데이터를 받아오거나 수동으로 DOM을 변경하는 작업 등등.
  - 의존성 배열을 넣지 않으면, 렌더링이 일어날 때마다 계속 create 함수가 실행됨 -> 이는 아무 의미가 없음.
  - 의존성 배열에 빈 배열을 넣으면, 마운트 시점에만 실행됨.
    - 마운트 시점에 한 번만 계산되는 경우에는 빈 배열 넣으면 됨.
    - 하지만 대부분은 의존성 배열에 값을 넣고, 값의 변화에 따라 새로 값을 계산하는 경우에 사용함
- useCallback
  - useMemo와 유사하지만, 값이 아닌 함수를 반환
  - 의존성 배열의 값이 바뀐 경우에만 함수를 새로 정의해서 return하는 것임.
  - 파라미터로 callback 함수와 의존성 배열 받음.
  - 컴포넌트 내에 정의된 함수는 매 렌더링 시 새로 정의되는데, useCallback을 활용하여 불필요한 반복 작업을 줄이는 것임.
  - 빈 배열이 들어간 경우에는, 마운트 시점에만 함수가 정의됨.
- useRef
  - reference를 사용하기 위한 훅
    - reference: 특정 컴포넌트에 접근할 수 있는 객체
    - useRef 훅이 특정 컴포넌트에 접근할 수 있는 객체를 반환함.
    - refObject.current 속성이 있는데, 현재 참조하고 있는 엘리먼트를 의미함.
    - const refContainer = useRef(초깃값)
      - 파라미터로 초기값을 넣으면 해당 초기값으로 초기화된 레퍼런스 객체를 반환함.
      - 이렇게 반환된 레퍼런스 객체는 컴포넌트의 라이프타임 전체에 걸져서 유지됨. 컴포넌트 마운트 해제 전까지.
      - 쉽게 말해서, 변경 가능한 current라는 속성을 가진 하나의 상자라고 생각하면 됨.
      - useRef에서 반환된 객체를 DOM 노드의 ref 속성에 넣어주면, 해당 노드가 변경될 때마다 uesRef에서 반환된 객체의 current 속성에 현재 해당되는 DOM 노드를 저장함.
      - 클래스의 인스턴스 필드를 사용하는 것과 유사하게 다양한 변수를 저장할 수 있다는 장점 있음. -> 일반적인 JS 객체를 리턴하기 때문임.
      - 매번 렌더링 될 때마다 항상 같은 레퍼런스 객체를 반환함.
      - 내부의 데이터가 변경되었을 때 별도로 알리지 않음. 그래서 current 속성을 변경한다고 해서 재렌더링이 일어나지는 않음.
      - DOM 노드의 변화를 알고 싶다면 callback ref를 사용해야 함.
        - react는 ref가 다른 노드에 연결될 때마다 callback을 호출하게 됨.
        - 그냥 useRef를 사용하면 레퍼런스 객체가 current 속성이 변경되었는지를 따로 알려주지 않음. 하지만 callback ref를 사용하면, 자식 컴포넌트가 변경되었을 때 알림 받을 수 있고, 다른 정보들도 업데이트 할 수 있음.

### 추가 공부

- 의존성 배열이 빈 배열이면, unmount 시에도 실행되나?
- useRef, useCallback-ref 좀 더 살펴보기!
