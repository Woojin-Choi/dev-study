### 강의 내용

- Context
  - 기존에는 컴포넌트의 props를 통해 부모에서 자식으로 '단방향'으로 데이터가 전달되었음.
  - 하지만 기존 방식은 코드도 복잡해지고 사용에 불편함이 있었음 -> 그래서 나온게 context임.
  - context는 props 대신 리액트 컴포넌트 트리를 통해 곧바로 컴포넌트로 데이터를 전달하는 새로운 방식임 -> 이를 통해 어떤 컴포넌트든 데이터에 쉽게 접근 가능
  - 기존 방식
    - 상위 컴포넌트에서 하위 컴포넌트로 props로 데이터 전달.
    - 여러 곳에서 자주 사용되는 데이터를 전달하기 위해 반복적인 코드를 많이 작성해야 함. 루트 노드에서 최하위 노드로 전달하는 경우도 있음.
  - context를 사용한 방식
    - props로 전달할 필요 없이 곧바로 컴포넌트에 데이터 전달 가능.
    - 코드도 깔끔해지고, 한 곳에서 관리하기 때문에 디버깅을 하기에도 유리함.
- 언제 context를 사용?
  - 여러 개의 컴포넌트 들이 접근해야 하는 데이터
    - 로그인 여부, 로그인 정보, UI 테마, 현재 선택된 언어 등.
    - 현재 지역 정보, 캐싱된 데이터 등.
- context 사용법
  - const ThemeContext = React.createContext('')로 컨텍스트 정의해주고
  - ThemeContext.Provider와 ThemeContext.Consumer로 감싸서 데이터 전달
  - provider와 consumer로 감싸진 컴포넌트는 얼마나 깊이 있는지에 관계 없이 context의 데이터를 읽을 수 있음.
- context를 사용하기 전에 고려할 점.
  - 무조건 context를 사용한다고 좋은 것만은 아님 -> 컴포넌트가 context를 사용할 경우 재사용성이 떨어지기 때문.
  - 다른 레벨의 많은 컴포넌트가 동일한 데이터를 필요로 하는 경우가 아니라면, 기존 props 방식을 통한 component composition 방법을 활용하는 것이 적합함.
- 하위 컴포넌트로 동일한 props 계속 넘겨줘야 하는 경우
  - context를 사용하지 않는다면
    - 하위의 컴포넌트 일부를 변수에 담아 props로 넘겨주면, 여러 props를 넘기지 않아도 됨.
    - 중간 레벨의 props를 없애고 코드를 간결하게 만들어 줌.
    - 최상위 컴포넌트에 좀 더 많은 권한을 부여.
    - 하지만, 상위컴포넌트에 몰리면서 상위 컴포넌트는 더 복잡해지고 하위 컴포넌트는 너무 유연해짐.
  - 하위 컴포넌트를 여러 개의 변수로 나눠서 전달하기도 함.
    - 하위 컴포넌트의 의존성을 상위 컴포넌트와 분리할 필요가 있는 경우에 적합한 방식.
    - 렌더링 전에 하위 컴포넌트가 상위 컴포넌트와 통신해야 하는 경우 render props를 사용하여 처리할 수도 있음.
  - 하나의 데이터에 여러 레벨의 컴포넌트가 접근해야 하는 경우에는 context를 사용해야 함.
    - context가 해당 데이터와 데이터의 변경사항을 하위 컴포넌트들에게 모두 broadcast 해주기 때문임.

---

- Context API
  - React.createContext(기본값)
    - 렌더링 발생 시 컨텍스트로 구독하는 하위 컴포넌트가 나오면, 현재의 컨텍스트 값을 가장 가까이에 있는 상위 레벨의 provider를 통해 받아옴
    - 만약 매칭되는 provider가 없다면 기본값이 사용됨.
    - 기본 값으로 undefined를 넣으면 기본값이 사용되지 않음.
  - Context.Provider
    - 데이터를 제공해주는 컴포넌트
    - 모든 컨텍스트 객체는 이를 갖고 있음.
    - provider의 모든 하위 컴포넌트들이 해당 데이터에 접근할 수 있게 됨.
    - provider 에는 value 프로퍼티가 있는데, 이는 하위 컴포넌트들에 모두 전달됨. 하위 컴포넌트들이 이 값을 소비한다는 의미에서 consuming component라고 부름.
    - 컨텍스트 값을 지켜보다가, 값이 변화하면 재 렌더링 됨.
    - 모든 하위 컴포넌트는 provider의 value prop이 바뀔 때마다 재 랜더링 됨.
    - 값의 변화를 판단하는 기준은 JS의 object.is와 같은 방식으로 판단함.
    - provider 컴포넌트가 재랜더링 될 때마다 모든 하위 consumer 컴포넌트가 재렌더링 됨. 왜냐하면 value prop을 위한 새로운 객체가 매번 새롭게 생성되기 때문임. -> 이를 방지하기 위해서는 prop에 직접 객체를 넣는게 아니라 state로 값을 옮기고 이 값을 넣어줘야 함.
  - Class.contextType 를 통해 값에 접근할 수도 있음
    - 지금은 class 컴포넌트가 거의 쓰이지 않으니 이런게 있다 정도만 알아두기.
  - Context.Consumer
    - context의 데이터를 구독하는 컴포넌트
    - 클래스 컴포넌트에서는 class.contextType을 사용하면 되고, 함수 컴포넌트에서는 context.consumer을 사용하여 컨텍스트를 구독할 수 있음.
    - 컴포넌트의 자식으로 함수가 올 수 있는데, 이를 function as a child라고 함.
    - consumer로 감싸주면 자식으로 들어간 함수가 현재 컨텍스트의 value를 받아서 리액트 노드로 리턴해 줌. 이때 함수로 전달되는 value는 provider의 value prop과 동일함.
  - function as a child
    - 컴포넌트의 자식으로 함수를 사용하는 방법
  - Context.displayName
    - context 객체는 displayName을 가지고, 개발자 도구에서는 이를 표시해 줌.
  - 여러 개의 context를 동시에 사용할 수 있음
    - 하지만 2개 혹은 그 이상의 값이 자주 함께 사용될 경우, 모든 값을 한 번에 제공해주는 별도의 render prop context를 직접 만드는 것을 고려해볼 수 있음.
  - useContext
    - 함수 컴포넌트에서 컨텍스트 사용하는 방법을 아는 것이 중요한데, 매번 consumer로 감싸주면 번거로움 -> 이를 위해 useContext라는 훅이 있음
    - 함수 컴포넌트에서 컨텍스트를 쉽게 사용하게 해줌.
    - 콘텍스트 값이 변경되면, 해당 useContext를 사용하는 컴포넌트가 재렌더링 됨 -> 그래서 무거운 렌더링 작업일 경우에는 별도로 최적화 작업이 필요함
    - useContext의 파라미터로 컨텍스트 객체를 넣어줘야 함.

### 추가 공부

- 리액트는 단뱡향임. 그럼 양방향이 가능한 JS 라이브러리는?
- 디버깅의 정확한 의미?
- render props 개념?
-
